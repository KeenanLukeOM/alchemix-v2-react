import{aR as m,aS as b,aT as C,aU as I,ao as A,aV as w,aW as _,aX as D,aY as T,aZ as P,a_ as E,a$ as q,b0 as R,b1 as v,b2 as x,b3 as Q,b4 as U,b5 as N,b6 as W,b7 as z,b8 as F,b9 as K,n as O,Y as k,ba as Y,z as f,bb as M}from"./index-iftjwR5s.js";async function S(e,{chain:t}){const{id:s,name:a,nativeCurrency:o,rpcUrls:n,blockExplorers:r}=t;await e.request({method:"wallet_addEthereumChain",params:[{chainId:m(s),chainName:a,nativeCurrency:o,rpcUrls:n.default.http,blockExplorerUrls:r?Object.values(r).map(({url:c})=>c):void 0}]},{dedupe:!0,retryCount:0})}function V(e,t){const{abi:s,args:a,bytecode:o,...n}=t,r=b({abi:s,args:a,bytecode:o});return C(e,{...n,data:r})}async function j(e){var s;return((s=e.account)==null?void 0:s.type)==="local"?[e.account.address]:(await e.request({method:"eth_accounts"},{dedupe:!0})).map(a=>I(a))}async function B(e){return await e.request({method:"wallet_getPermissions"},{dedupe:!0})}async function H(e){return(await e.request({method:"eth_requestAccounts"},{dedupe:!0,retryCount:0})).map(s=>A(s))}async function X(e,t){return e.request({method:"wallet_requestPermissions",params:[t]},{retryCount:0})}async function Z(e,t){var i,u,y,h;const{account:s=e.account,chain:a=e.chain,...o}=t;if(!s)throw new w({docsPath:"/docs/actions/wallet/signTransaction"});const n=q(s);_({account:n,...t});const r=await D(e,T,"getChainId")({});a!==null&&P({currentChainId:r,chain:a});const c=(a==null?void 0:a.formatters)||((i=e.chain)==null?void 0:i.formatters),d=((u=c==null?void 0:c.transactionRequest)==null?void 0:u.format)||E;return n.signTransaction?n.signTransaction({...o,chainId:r},{serializer:(h=(y=e.chain)==null?void 0:y.serializers)==null?void 0:h.transaction}):await e.request({method:"eth_signTransaction",params:[{...d(o),chainId:m(r),from:n.address}]},{retryCount:0})}async function $(e,t){const{account:s=e.account,domain:a,message:o,primaryType:n}=t;if(!s)throw new w({docsPath:"/docs/actions/wallet/signTypedData"});const r=q(s),c={EIP712Domain:R({domain:a}),...t.types};if(v({domain:a,message:o,primaryType:n,types:c}),r.signTypedData)return r.signTypedData({domain:a,message:o,primaryType:n,types:c});const d=x({domain:a,message:o,primaryType:n,types:c});return e.request({method:"eth_signTypedData_v4",params:[r.address,d]},{retryCount:0})}async function G(e,{id:t}){await e.request({method:"wallet_switchEthereumChain",params:[{chainId:m(t)}]},{retryCount:0})}async function J(e,t){return await e.request({method:"wallet_watchAsset",params:t},{retryCount:0})}function g(e){return{addChain:t=>S(e,t),deployContract:t=>V(e,t),getAddresses:()=>j(e),getChainId:()=>T(e),getPermissions:()=>B(e),prepareTransactionRequest:t=>Q(e,t),requestAddresses:()=>H(e),requestPermissions:t=>X(e,t),sendRawTransaction:t=>U(e,t),sendTransaction:t=>C(e,t),signMessage:t=>N(e,t),signTransaction:t=>Z(e,t),signTypedData:t=>$(e,t),switchChain:t=>G(e,t),watchAsset:t=>J(e,t),writeContract:t=>W(e,t)}}async function L(e,t={}){const s=await z(e,t);return s.extend(g),s.extend(g)}function ee(e,t={}){return{gcTime:0,async queryFn({queryKey:s}){const{connector:a}=t,{connectorUid:o,scopeKey:n,...r}=s[1];return L(e,{...r,connector:a})},queryKey:te(t)}}function te(e={}){const{connector:t,...s}=e;return["walletClient",{...F(s),connectorUid:t==null?void 0:t.uid}]}function ae(e={}){const{query:t={},...s}=e,a=K(s),o=O(),{address:n,connector:r,status:c}=k({config:a}),d=Y({config:a}),i=e.connector??r,{queryKey:u,...y}=ee(a,{...e,chainId:e.chainId??d,connector:e.connector??r}),h=!!((c==="connected"||c==="reconnecting"&&(i!=null&&i.getProvider))&&(t.enabled??!0)),p=f.useRef(n);return f.useEffect(()=>{const l=p.current;!n&&l?(o.removeQueries({queryKey:u}),p.current=void 0):n!==l&&(o.invalidateQueries({queryKey:u}),p.current=n)},[n,o]),M({...t,...y,queryKey:u,enabled:h,staleTime:Number.POSITIVE_INFINITY})}export{ae as u};
